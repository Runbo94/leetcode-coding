# 621. Task Scheduler

[原题链接](https://leetcode.com/problems/task-scheduler/)

这道题让我们安排 CPU 的任务，规定在两个相同任务之间至少隔 n 个时间点。由于题目中规定了两个相同任务之间至少隔 n 个时间点，那么我们首先应该处理出现次数最多的那个任务，先确定这些高频任务，然后再来安排那些低频任务。如果任务 F 的出现频率最高，为 k 次，那么我们用 n 个空位将每两个 F 分割开，然后我们按顺序加入其他低频的任务，来看一个例子：

AAAABBBEEFFGG n=3

我们发现任务 A 出现 4 次，频率最高，于是我们在每个 A 中间加入三个空位，如下：

A---A---A---A

AB--AB--AB--A (加入 B)

ABE-ABE-AB--A (加入 E)

ABEFABE-ABF-A (加入 F，每次尽可能填满或者是均匀填充)

ABEFABEGABFGA (加入 G)

再来看一个例子：

ACCCEEE n=2

我们发现任务 C 和 E 都出现了三次，那么我们就将 CE 看作一个整体，在中间加入一个位置即可：

CE-CE-CE

CEACE-CE (加入 A)

注意最后面那个 idle 不能省略，不然就不满足相同两个任务之间要隔 2 个时间点了。

这道题好在没有让我们输出任务安排结果，而只是问所需的时间总长，那么我们就想个方法来快速计算出所需时间总长即可。我们仔细观察上面两个例子可以发现，都分成了(mx - 1)块，再加上最后的字母，其中 mx 为最大出现次数。比如例子 1 中，A 出现了 4 次，所以有 A---模块出现了 3 次，再加上最后的 A，每个模块的长度为 4。例子 2 中，CE-出现了 2 次，再加上最后的 CE，每个模块长度为 3。我们可以发现，模块的次数为任务最大次数减 1，模块的长度为 n+1，最后加上的字母个数为出现次数最多的任务，可能有多个序列。这样三个部分都搞清楚了，写起来就不难了，我们统计每个大写字母出现的次数，然后排序，这样我出现次数最长的字母就到了末尾，然后我们向前遍历，找出出现次数一样多的任务个数，就可以迅速求出总时间长了，下面这段代码可能最不好理解的可能就是最后一句了，那么我们特别来讲解一下。先看括号中的第二部分，前面分析说了 mx 是出现的最大次数，mx-1 是可以分为的块数，n+1 是每块中的个数，而后面的 25-i 是还需要补全的个数，用之前的例子来说明：
AAAABBBEEFFGG 3

A 出现了 4 次，最多，mx=4，那么可以分为 mx-1=3 块，如下:

A---A---A---

每块有 n+1=4 个，最后还要加上末尾的一个 A，也就是 25-24=1 个任务，最终结果为 13：

ABEFABEGABFGA

再来看另一个例子：

ACCCEEE 2

C 和 E 都出现了 3 次，最多，mx=3，那么可以分为 mx-1=2 块，如下：

CE-CE-

每块有 n+1=3 个，最后还要加上末尾的一个 CE，也就是 25-23=2 个任务，最终结果为 8：

CEACE-CE

好，那么此时你可能会有疑问，为啥还要跟原任务个数 len 相比，取较大值呢？我们再来看一个例子：

AAABBB 0

A 和 B 都出现了 3 次，最多，mx=3，那么可以分为 mx-1=2 块，如下：

ABAB

每块有 n+1=1 个？你会发现有问题，这里明明每块有两个呀，为啥这里算出来 n+1=1 呢，因为给的 n=0，这里没有矛盾呢，没有！因为 n 表示相同的任务间需要间隔的个数，那么既然这里为 0 了，说明相同的任务可以放在一起，这里就没有任何限制了，我们只需要执行完所有的任务就可以了，所以我们最终的返回结果一定不能小于任务的总个数 len 的，这就是要对比取较大值的原因了。
